# Online Radio DJ - System Design Document

## 1. Executive Summary
The **Online Radio DJ** is an autonomous, AI-driven internet radio station platform. It replaces legacy desktop automation tools (like RoboDJ) with a modern, web-based, cloud-native architecture. It integrates seamlessly with the "AI Music Agents" ecosystem to broadcast AI-generated music alongside human-curated tracks, hosted by dynamic AI personalities.

## 2. Architecture Overview

### A. Core Components
1.  **Frontend (Next.js)**:
    -   **Dashboard**: Manage schedules, playlists, and AI host personalities.
    -   **Studio View**: Real-time visualizer of the broadcast queue and audio levels.
    -   **Public Player**: Embeddable web player for listeners.
2.  **Backend (Python FastAPI)**:
    -   **Scheduler Engine**: Determines what plays next (Music vs. Talk).
    -   **Content Manager**: CRUD for Tracks, Prompts, and Ad/Promo spots.
    -   **Agent Orchestrator**: Manages the "DJ Agent" lifecycle.
3.  **Audio Pipeline (Python/FFmpeg/Liquidsoap)**:
    -   **Streamer**: Generates the continuous audio stream (Icecast/HLS).
    -   **Mixer**: Handles crossfades, ducking (lowering music volume during speech), and FX.
    -   **Synthesizer**: Interfacing with TTS providers (ElevenLabs, OpenAI).

### B. Integration with AI Music Agents
-   **Source Material**: Automatically ingests tracks generated by the `Composer` and `Producer` agents.
-   **Metadata**: Reads rich metadata (Mood, BPM, Key, Genre) to inform DJ scripts and transitions.
-   **Live Interaction**: The DJ Agent can "interview" the Musician Agents about their new tracks.

## 3. Detailed Modules

### 3.1. The DJ Agent ("Host")
*A specialized agent responsible for the "Voice" of the station.*

-   **Persona Profile**:
    -   `Name`, `Backstory`, `VoiceID`, `Tone` (e.g., "Hype", "Chill", "NPR-style").
    -   `Knowledge Base`: Access to artist bios, song facts, weather, and news.
-   **Scripting Engine (LLM)**:
    -   Generates "Links" (speech between songs).
    -   **Input**: Previous Song, Next Song, Station ID, Current Time, Weather, Listener Requests.
    -   **Output**: Natural language script with SSML tags for emotional inflection.

### 3.2. Scheduler & Playlist Manager
*The "Brain" that decides the programming.*

-   **Clock Wheels**: Define templates for an hour (e.g., "Top of Hour ID" -> "Power Hit" -> "DJ Link" -> "New Release").
-   **Rules Engine**:
    -   *Artist Separation*: "Don't play the same artist within 60 minutes."
    -   *Tempo Flow*: "Gradually increase BPM from 6 PM to 9 PM."

### 3.3. Streaming Server
*The "Mouth" that broadcasts to the world.*

-   **Protocol**: HLS (HTTP Live Streaming) for low-latency web playback, or Icecast for compatibility.
-   **Transcoding**: Real-time encoding to AAC/MP3.
-   **Metadata Push**: Updates "Now Playing" info on the frontend.

## 4. Data Model (Draft Schema)

### Multi-tenant baseline
All **station-owned entities** must include a tenant field:

- `station_id: uuid` (required, indexed, immutable after create)

Station-owned entities include:

- `Track`
- `BroadcastQueueItem`
- `ClockWheel`
- `Schedule`
- `Prompt`
- `PromoSpot`
- `HostPersona`
- `VoiceLinkTemplate`
- `ListenerRequest`
- `AutomationRule`
- `NowPlayingEvent`
- `Asset` (audio files, jingles, beds)
- `IntegrationCredential` (scoped to one station; encrypted at rest)

Global entities (no `station_id`) are limited to platform-level references such as provider catalogs, runtime health metrics, and feature flags.

### Tracks
```json
{
  "id": "uuid",
  "station_id": "uuid",
  "title": "Neon Nights",
  "artist": "AI Synthwave Collective",
  "duration": 245,
  "intro_duration": 12,
  "outro_duration": 15,
  "file_path": "s3://...",
  "bpm": 128,
  "energy": 0.8
}
```

### BroadcastQueue
```json
{
  "id": "uuid",
  "station_id": "uuid",
  "scheduled_time": "2023-10-27T14:00:00Z",
  "item_type": "track | voice_link | jingle",
  "item_id": "uuid",
  "status": "pending | playing | played"
}
```

### Identity and authorization model

#### User
```json
{
  "id": "uuid",
  "email": "ops@station.com",
  "display_name": "Alex Producer",
  "is_active": true,
  "memberships": [
    {
      "station_id": "uuid",
      "role_id": "uuid"
    }
  ]
}
```

#### Role
```json
{
  "id": "uuid",
  "station_id": "uuid",
  "name": "Program Director",
  "description": "Can manage content and publish schedules",
  "scopes": ["read", "write", "publish"]
}
```

#### Permission scopes
- `read`: view station resources and analytics.
- `write`: create/update/delete station resources (tracks, prompts, schedules, queue adjustments).
- `publish`: execute state changes that affect live output (publish schedule, trigger go-live, force queue play, approve generated links).
- `admin`: station governance (user invites, role management, credentials/integrations, destructive station settings).

Scope hierarchy: `admin` implies `publish`, `write`, and `read`; `publish` implies `write` + `read`; `write` implies `read`.

Enforcement rule: API authorization is always evaluated against both `(user_id, station_id)` membership and required scope.

## 5. API station-context requirements

### Required station context in payloads
For all station-owned resources, API requests must include station context by one of these mechanisms:

1. Path scoping (preferred): `/api/stations/{station_id}/...`
2. Body field (required for create/upsert if not path-scoped): `station_id`
3. Event envelope metadata (async workers/webhooks): `{"station_id":"..."}`

If station context is missing or does not match authenticated membership, return `403` for unauthorized station access or `400` for malformed payload.

### Endpoint patterns that must carry station context
- Authenticated list/query: tracks, prompts, schedules, clock wheels, queue items, promo spots, host personas, listener requests.
- Mutations: create/update/delete for all station-owned resources.
- Live actions: publish schedule, regenerate segment, trigger voice link, enqueue/dequeue, force-skip.
- Analytics: dashboard metrics, now-playing history, performance reports.

### Example payloads
```http
POST /api/stations/{station_id}/tracks
{
  "title": "Neon Nights",
  "artist": "AI Synthwave Collective",
  "duration": 245
}
```

```http
POST /api/queue/enqueue
{
  "station_id": "uuid",
  "item_type": "track",
  "item_id": "uuid"
}
```

## 6. Frontend data filtering requirements

- Resolve active station at login/session restore (station switcher or last-used station).
- Persist active station in app state and include it in every API call.
- Filter all client caches by `station_id` key to prevent cross-station leakage.
- Hide/disable UI actions if user lacks required role scope for the active station.
- On station switch, clear station-scoped stores (queue, tracks, prompts, dashboard metrics) before refetching.
- Never render mixed-station lists in shared components; enforce query-level filtering first, then defensive client-side filtering.

Recommended cache keys:
- `['station', station_id, 'tracks']`
- `['station', station_id, 'queue']`
- `['station', station_id, 'schedule', date]`
- `['station', station_id, 'prompts']`

## 7. Dashboard action-to-permission matrix

| Dashboard Action | Required Scope | Notes |
|---|---|---|
| View dashboard KPIs and now-playing | `read` | Station-scoped metrics only |
| View track library and metadata | `read` | No mutation controls |
| Upload/edit/delete tracks | `write` | Includes artwork and tags |
| Create/edit prompts and host persona settings | `write` | Content authoring actions |
| Build/edit clock wheels and schedules | `write` | Draft changes allowed |
| Publish schedule to live playout | `publish` | Affects on-air output |
| Force queue reorder/skip/play-next | `publish` | Real-time broadcast control |
| Approve generated AI link for air | `publish` | Treated as live editorial action |
| View user roster and role assignments | `admin` | Station membership management |
| Invite/remove users | `admin` | Station boundary enforced |
| Create/update roles and scopes | `admin` | Cannot exceed caller's own max scope |
| Configure integration credentials and secrets | `admin` | Sensitive operations, audited |

## 8. Implementation Plan

### Phase 1: Core Engine (MVP)
-   [ ] Python script to generate a single "Show" (MP3 file) from a list of songs.
-   [ ] Basic LLM integration to announce song titles.
-   [ ] Simple crossfade mixing.

### Phase 2: Streaming & Scheduling
-   [ ] Implement Shoutcast/Icecast server connection.
-   [ ] Build the "Clock Wheel" scheduler logic.
-   [ ] Real-time weather/time injection.

### Phase 3: Web Integration
-   [ ] Admin Dashboard for uploading tracks and configuring DJ.
-   [ ] Public Player with "Now Playing" data.

## 9. Technology Stack Recommendations
-   **Language**: Python 3.11+ (Backend), TypeScript (Frontend).
-   **Audio Processing**: `pydub` (simple) or `ffmpeg-python` (complex).
-   **Streaming**: `Liquidsoap` (industry standard for radio automation) or custom FFmpeg stream.
-   **Database**: PostgreSQL (robustness) or SQLite (simplicity).
-   **AI**: LangChain (orchestration), OpenAI/Anthropic (LLM), ElevenLabs (TTS).
